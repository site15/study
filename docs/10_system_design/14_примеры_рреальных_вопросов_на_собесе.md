## 1️⃣3️⃣ **Примеры реальных вопросов на собесе и ответы**

---

### 1️⃣ Спроектируй систему чата на миллионы пользователей

**Подход к ответу:**

1. Разделяем на микросервисы:

   - **AuthService** → авторизация пользователей
   - **UserService** → профили и друзья
   - **ChatService** → хранение сообщений
   - **NotificationService** → push/email
   - **API Gateway / BFF** → агрегация и авторизация

2. Базы данных:

   - SQL (Postgres) → пользователи и связи
   - NoSQL (MongoDB) → хранение сообщений
   - Redis → кэш последних сообщений / presence

3. Масштабирование:

   - Node.js cluster + Kubernetes pods
   - Horizontal scaling микросервисов
   - Шардирование по userId / tenantId

4. Асинхронность:

   - RabbitMQ / Kafka для событий (message_sent, user_online)

**Пример объяснения на собесе:**

> “Для чата миллионы пользователей мы используем микросервисы, шардируем сообщения по userId, кэшируем последние сообщения в Redis и обрабатываем события через Kafka, чтобы уменьшить задержки и decouple сервисы.”

---

### 2️⃣ Как хранить и искать историю сообщений?

**Подход:**

- **NoSQL document store** → MongoDB / DynamoDB

  - Каждый документ = чат/комната с массивом сообщений или отдельные документы на сообщение

- **Индексы** → по chatId, timestamp, userId
- **Поиск по тексту** → Elasticsearch / Algolia для full-text
- **Архивация** → старые сообщения в cold storage (S3 / Glacier)

**Ответ на собесе:**

> “Храню последние N сообщений в MongoDB с индексами по chatId и timestamp, полный текст для поиска отдаю в Elasticsearch, а старые сообщения архивирую в S3.”

---

### 3️⃣ Как обеспечить масштабируемость и отказоустойчивость?

**Подход:**

- Горизонтальное масштабирование сервисов (Node.js cluster + K8s pods)
- Репликация БД + sharding
- Load Balancer (Nginx / HAProxy)
- Health checks + readiness/liveness probes
- Circuit breakers + retry + backoff для внешних сервисов

**Ответ на собесе:**

> “Все сервисы горизонтально масштабируемые, БД реплицированы, Load Balancer распределяет трафик, а circuit breakers и retries предотвращают cascade failures.”

---

### 4️⃣ Как реализовать уведомления (push/email) с гарантией доставки?

**Подход:**

- **Очередь задач** → RabbitMQ / Kafka / Redis Streams
- **Dead Letter Queue (DLQ)** для неудачных уведомлений
- Retry с экспоненциальной задержкой
- Idempotency → повторные запросы не дублируют отправку

**Ответ на собесе:**

> “Используем RabbitMQ для очередей уведомлений, DLQ для failed messages, retries с backoff и idempotent обработку для гарантированной доставки.”

---

### 5️⃣ Как организовать аналитическую подсистему на миллионах событий?

**Подход:**

- Event-driven architecture → Kafka или NATS Streaming
- Consumer → stream processing (Node.js / Python / Spark)
- Storage → ClickHouse / BigQuery / Redshift для аналитики
- Aggregations → batch vs real-time
- Retention policies → старые события архивируем

**Ответ на собесе:**

> “Все события публикуются в Kafka, real-time consumers агрегируют данные и пишут в ClickHouse, batch-процессы формируют отчеты для аналитики.”

---

### 6️⃣ Объясни, как использовать кэш, очереди, брокеры сообщений и базы данных вместе

**Подход:**

- **DB** → source of truth
- **Cache (Redis)** → ускорение чтения, reduce load
- **Queue (RabbitMQ/Kafka)** → асинхронная обработка и decoupling
- **Event-driven** → события между сервисами

**Пример:**

- OrderService пишет в DB → публикует событие order_created → InventoryService читает из queue → обновляет stock → NotificationService читает события → отправляет уведомления

**Ответ на собесе:**

> “DB хранит источник правды, Redis ускоряет чтение, очереди decouple сервисы и позволяют обрабатывать события асинхронно, а Event-driven подход обеспечивает надежность и масштабируемость.”

---

### 7️⃣ Как обработать spike трафика без падения системы?

**Подход:**

- Load balancer + auto-scaling на Kubernetes
- Rate limiting на API Gateway / BFF
- Queues → асинхронная обработка задач, backpressure handling
- Cache → уменьшает load на DB
- Circuit breaker → защищает downstream сервисы

**Ответ на собесе:**

> “Spike трафика решаем горизонтальным масштабированием, лимитами на API, кэшированием и асинхронной обработкой через очереди, а circuit breakers защищают критичные сервисы.”

---

### 8️⃣ Дополнительные примеры вопросов

1. Спроектируй URL-shortener на миллионы пользователей
2. Как хранить и выдавать ленту новостей (news feed)
3. Как реализовать realtime collaborative editing (Google Docs-like)
4. Как хранить метрики для миллионов пользователей (analytics)
5. Как организовать search & recommendation system

**Краткий подход к ответам:**

- Разделить на микросервисы
- Выбрать правильную базу данных / кеш / очередь / брокер сообщений
- Подумать о масштабировании и отказоустойчивости
- Event-driven + асинхронная обработка
- Monitoring и alerting
